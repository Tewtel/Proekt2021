// Decompiled with JetBrains decompiler
// Type: System.Data.Entity.Migrations.Design.MigrationCodeGenerator
// Assembly: EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089
// MVID: 13DB822D-E6C4-49C2-A425-BD1B471FFCED
// Assembly location: D:\labs\2semestr\ProektObnovaCode\AvitoRinger\EntityFramework.dll

using System.Collections.Generic;
using System.Data.Entity.Core.Metadata.Edm;
using System.Data.Entity.Infrastructure.Annotations;
using System.Data.Entity.Migrations.Model;
using System.Linq;

namespace System.Data.Entity.Migrations.Design
{
  /// <summary>
  /// Base class for providers that generate code for code-based migrations.
  /// </summary>
  public abstract class MigrationCodeGenerator
  {
    private readonly IDictionary<string, Func<AnnotationCodeGenerator>> _annotationGenerators = (IDictionary<string, Func<AnnotationCodeGenerator>>) new Dictionary<string, Func<AnnotationCodeGenerator>>();

    /// <summary>
    /// Generates the code that should be added to the users project.
    /// </summary>
    /// <param name="migrationId"> Unique identifier of the migration. </param>
    /// <param name="operations"> Operations to be performed by the migration. </param>
    /// <param name="sourceModel"> Source model to be stored in the migration metadata. </param>
    /// <param name="targetModel"> Target model to be stored in the migration metadata. </param>
    /// <param name="namespace"> Namespace that code should be generated in. </param>
    /// <param name="className"> Name of the class that should be generated. </param>
    /// <returns> The generated code. </returns>
    public abstract ScaffoldedMigration Generate(
      string migrationId,
      IEnumerable<MigrationOperation> operations,
      string sourceModel,
      string targetModel,
      string @namespace,
      string className);

    private static bool AnnotationsExist(MigrationOperation[] operations) => operations.OfType<IAnnotationTarget>().Any<IAnnotationTarget>((Func<IAnnotationTarget, bool>) (o => o.HasAnnotations));

    /// <summary>
    /// Gets the namespaces that must be output as "using" or "Imports" directives to handle
    /// the code generated by the given operations.
    /// </summary>
    /// <param name="operations"> The operations for which code is going to be generated. </param>
    /// <returns> An ordered list of namespace names. </returns>
    protected virtual IEnumerable<string> GetNamespaces(
      IEnumerable<MigrationOperation> operations)
    {
      System.Data.Entity.Utilities.Check.NotNull<IEnumerable<MigrationOperation>>(operations, nameof (operations));
      IEnumerable<string> strings = this.GetDefaultNamespaces();
      MigrationOperation[] array = operations.ToArray<MigrationOperation>();
      if (array.OfType<AddColumnOperation>().Any<AddColumnOperation>((Func<AddColumnOperation, bool>) (o => o.Column.Type == PrimitiveTypeKind.Geography || o.Column.Type == PrimitiveTypeKind.Geometry)))
        strings = strings.Concat<string>((IEnumerable<string>) new string[1]
        {
          "System.Data.Entity.Spatial"
        });
      if (array.OfType<AddColumnOperation>().Any<AddColumnOperation>((Func<AddColumnOperation, bool>) (o => o.Column.Type == PrimitiveTypeKind.HierarchyId)))
        strings = strings.Concat<string>((IEnumerable<string>) new string[1]
        {
          "System.Data.Entity.Hierarchy"
        });
      if (MigrationCodeGenerator.AnnotationsExist(array))
      {
        IEnumerable<string> seed = strings.Concat<string>((IEnumerable<string>) new string[2]
        {
          "System.Collections.Generic",
          "System.Data.Entity.Infrastructure.Annotations"
        });
        strings = this.AnnotationGenerators.Select<KeyValuePair<string, Func<AnnotationCodeGenerator>>, Func<AnnotationCodeGenerator>>((Func<KeyValuePair<string, Func<AnnotationCodeGenerator>>, Func<AnnotationCodeGenerator>>) (a => a.Value)).Where<Func<AnnotationCodeGenerator>>((Func<Func<AnnotationCodeGenerator>, bool>) (g => g != null)).Aggregate<Func<AnnotationCodeGenerator>, IEnumerable<string>>(seed, (Func<IEnumerable<string>, Func<AnnotationCodeGenerator>, IEnumerable<string>>) ((c, g) => c.Concat<string>(g().GetExtraNamespaces((IEnumerable<string>) this.AnnotationGenerators.Keys))));
      }
      return (IEnumerable<string>) strings.Distinct<string>().OrderBy<string, string>((Func<string, string>) (n => n));
    }

    /// <summary>
    /// Gets the default namespaces that must be output as "using" or "Imports" directives for
    /// any code generated.
    /// </summary>
    /// <param name="designer"> A value indicating if this class is being generated for a code-behind file. </param>
    /// <returns> An ordered list of namespace names. </returns>
    protected virtual IEnumerable<string> GetDefaultNamespaces(bool designer = false)
    {
      List<string> source = new List<string>()
      {
        "System.Data.Entity.Migrations"
      };
      if (designer)
      {
        source.Add("System.CodeDom.Compiler");
        source.Add("System.Data.Entity.Migrations.Infrastructure");
        source.Add("System.Resources");
      }
      else
        source.Add("System");
      return (IEnumerable<string>) source.OrderBy<string, string>((Func<string, string>) (n => n));
    }

    /// <summary>
    /// Gets the <see cref="T:System.Data.Entity.Infrastructure.Annotations.AnnotationCodeGenerator" /> instances that are being used.
    /// </summary>
    public virtual IDictionary<string, Func<AnnotationCodeGenerator>> AnnotationGenerators => this._annotationGenerators;
  }
}
